// src/lib/tools/geocoding.ts
import axios from 'axios';
import { GeocodingResult } from '@/types/safety';

interface NominatimResult {
  place_id: number;
  licence: string;
  osm_type: string;
  osm_id: number;
  lat: string;
  lon: string;
  display_name: string;
  class: string;
  type: string;
  importance: number;
}

export async function geocodeLocation(params: {
  location: string;
  country?: string;
}): Promise<GeocodingResult | null> {
  const { location, country } = params;
  
  console.log('Geocoding: Looking up coordinates for:', location);
  
  try {
    // Build query string
    let query = location;
    if (country) {
      query += `, ${country}`;
    }
    
    const response = await axios.get('https://nominatim.openstreetmap.org/search', {
      params: {
        q: query,
        format: 'json',
        limit: 1,
        addressdetails: 1,
        extratags: 1
      },
      headers: {
        'User-Agent': 'SafetyNewsApp/1.0'
      }
    });

    if (response.data && response.data.length > 0) {
      const result: NominatimResult = response.data[0];
      
      const geocodingResult: GeocodingResult = {
        coordinates: [parseFloat(result.lon), parseFloat(result.lat)],
        address: result.display_name,
        confidence: result.importance || 0.5
      };
      
      console.log('Geocoding: Found coordinates:', geocodingResult.coordinates);
      return geocodingResult;
    }
    
    console.log('Geocoding: No results found for:', location);
    return null;
    
  } catch (error) {
    console.error('Geocoding: Error:', error);
    return null;
  }
}

// Enhanced location extraction from text - SECURE VERSION
export function extractLocationFromText(text: string): string | null {
  // Input validation and length limit to prevent ReDoS
  if (!text || typeof text !== 'string' || text.length > 1000) {
    return null;
  }
  
  // Normalize input
  const normalizedText = text.toLowerCase().trim();
  
  // Simple string-based checks for known locations (fastest and most secure)
  const knownLocations = [
    'johannesburg', 'joburg', 'jozi',
    'cape town', 'capetown',
    'durban', 'ethekwini',
    'pretoria', 'tshwane',
    'bloemfontein',
    'port elizabeth', 'gqeberha',
    // Johannesburg suburbs
    'sandton', 'rosebank', 'parkhurst', 'melville', 'bryanston', 'fourways',
    'hyde park', 'illovo', 'morningside', 'rivonia', 'sunninghill',
    'soweto', 'alexandra', 'randburg', 'roodepoort', 'germiston',
    // Cape Town areas
    'camps bay', 'sea point', 'green point', 'waterfront', 'claremont',
    'stellenbosch', 'paarl', 'bellville', 'parow', 'goodwood'
  ];
  
  // Check for exact matches first (most secure)
  for (const location of knownLocations) {
    if (normalizedText.includes(location)) {
      return location;
    }
  }
  
  // Safe regex patterns - no nested quantifiers or backtracking risks
  const safeLocationPatterns = [
    // Simple "in Location" pattern with bounded length
    { regex: /\bin\s+([a-z]{2,20})\b/i, group: 1 },
    { regex: /\bin\s+([a-z]{2,20}\s[a-z]{2,20})\b/i, group: 1 },
    // Location followed by area/suburb
    { regex: /\b([a-z]{2,20})\s+area\b/i, group: 1 },
    { regex: /\b([a-z]{2,20})\s+suburb\b/i, group: 1 },
    { regex: /\b([a-z]{2,20}\s[a-z]{2,20})\s+area\b/i, group: 1 },
  ];
  
  for (const pattern of safeLocationPatterns) {
    const match = normalizedText.match(pattern.regex);
    if (match && match[pattern.group]) {
      return match[pattern.group].trim();
    }
  }
  
  return null;
}

// Alternative implementation using string operations (most secure)
export function extractLocationFromTextSecure(text: string): string | null {
  if (!text || typeof text !== 'string' || text.length > 1000) {
    return null;
  }
  
  const normalizedText = text.toLowerCase();
  
  // Known location keywords
  const locationKeywords = [
    'johannesburg', 'joburg', 'jozi', 'cape town', 'capetown',
    'durban', 'pretoria', 'sandton', 'rosebank', 'soweto',
    'camps bay', 'stellenbosch', 'bellville'
  ];
  
  // Find location keywords
  for (const keyword of locationKeywords) {
    if (normalizedText.includes(keyword)) {
      return keyword;
    }
  }
  
  // Look for "in [word]" or "[word] area" patterns using string operations
  const words = normalizedText.split(/\s+/);
  for (let i = 0; i < words.length - 1; i++) {
    if (words[i] === 'in' && words[i + 1].length > 2 && words[i + 1].length < 20) {
      return words[i + 1];
    }
    if (words[i + 1] === 'area' && words[i].length > 2 && words[i].length < 20) {
      return words[i];
    }
  }
  
  return null;
}

// src/lib/tools/classification.ts
import { CrimeType } from '@/types/safety';

export async function classifyCrime(params: {
  description: string;
  context?: string;
}): Promise<{ type: CrimeType; severity: number; keywords: string[] }> {
  const { description, context } = params;
  
  // Input validation
  if (!description || typeof description !== 'string') {
    throw new Error('Invalid description provided');
  }
  
  // Limit input length to prevent ReDoS
  const maxLength = 2000;
  const trimmedDescription = description.length > maxLength ? description.substring(0, maxLength) : description;
  const trimmedContext = context && context.length > maxLength ? context.substring(0, maxLength) : context;
  
  const text = `${trimmedDescription} ${trimmedContext || ''}`.toLowerCase();
  
  console.log('Classification: Analyzing crime type for:', trimmedDescription);
  
  // Extract keywords
  const keywords = extractKeywordsSecure(text);
  
  // Classify crime type
  const type = classifyCrimeTypeSecure(text);
  
  // Assess severity (1-5 scale)
  const severity = assessSeveritySecure(text);
  
  console.log('Classification: Result - Type:', type, 'Severity:', severity, 'Keywords:', keywords);
  
  return { type, severity, keywords };
}

function extractKeywordsSecure(text: string): string[] {
  // Secure keyword extraction using simple string operations
  const keywordCategories = {
    violence: ['murder', 'killing', 'homicide', 'shot', 'stabbed', 'assault', 'attack', 'violence'],
    robbery: ['robbery', 'robbed', 'mugging', 'hijacking', 'armed robbery'],
    theft: ['theft', 'stolen', 'stealing', 'shoplifting'],
    burglary: ['burglary', 'break-in', 'breaking and entering', 'housebreaking'],
    vandalism: ['vandalism', 'damage', 'graffiti'],
    vehicle: ['car theft', 'vehicle theft', 'hijacking', 'carjacking'],
    drugs: ['drugs', 'narcotics', 'dealing', 'trafficking', 'possession'],
    sexual: ['rape', 'sexual assault', 'sexual harassment'],
    weapons: ['gun', 'firearm', 'knife', 'weapon', 'armed'],
    locations: ['home', 'house', 'shop', 'store', 'mall', 'street', 'park'],
    time: ['night', 'evening', 'morning', 'afternoon']
  };
  
  const foundKeywords: string[] = [];
  
  // Use simple string includes() - no regex needed
  Object.values(keywordCategories).flat().forEach(keyword => {
    if (text.includes(keyword)) {
      foundKeywords.push(keyword);
    }
  });
  
  return [...new Set(foundKeywords)]; // Remove duplicates
}

function classifyCrimeTypeSecure(text: string): CrimeType {
  // Use simple string checks instead of complex regex
  const crimeTypeChecks = [
    {
      type: 'Violent Crimes' as CrimeType,
      keywords: ['murder', 'killing', 'homicide', 'shot', 'stabbed', 'assault', 'attack', 'violence', 'robbery', 'robbed', 'mugging', 'hijack']
    },
    {
      type: 'Sexual Offences' as CrimeType,
      keywords: ['rape', 'sexual assault', 'sexual', 'harassment']
    },
    {
      type: 'Property & Financial Crimes' as CrimeType,
      keywords: ['theft', 'stolen', 'burglary', 'break-in', 'fraud', 'scam', 'embezzlement', 'shoplifting']
    },
    {
      type: 'Cyber & Communication Crimes' as CrimeType,
      keywords: ['cyber', 'online', 'internet', 'email', 'phishing', 'hacking', 'digital']
    },
    {
      type: 'Organised Crime & Syndicate Operations' as CrimeType,
      keywords: ['gang', 'syndicate', 'organized', 'trafficking', 'money laundering', 'racketeering']
    }
  ];
  
  for (const check of crimeTypeChecks) {
    if (check.keywords.some(keyword => text.includes(keyword))) {
      return check.type;
    }
  }
  
  return 'Public Order & Social Crimes';
}

function assessSeveritySecure(text: string): number {
  let severity = 1; // Base severity
  
  // Use simple string checks for severity assessment
  const severityChecks = [
    { keywords: ['murder', 'killing', 'death', 'died', 'fatal'], severity: 5 },
    { keywords: ['shot', 'stabbed', 'injured', 'wounded', 'armed', 'gun', 'weapon'], severity: 4 },
    { keywords: ['assault', 'attack', 'robbery', 'hijack'], severity: 3 },
    { keywords: ['theft', 'stolen', 'break-in', 'burglary'], severity: 2 }
  ];
  
  for (const check of severityChecks) {
    if (check.keywords.some(keyword => text.includes(keyword))) {
      severity = Math.max(severity, check.severity);
    }
  }
  
  // Modifiers
  if (['multiple', 'several', 'gang', 'group'].some(keyword => text.includes(keyword))) {
    severity = Math.min(5, severity + 1);
  }
  
  if (['attempted', 'failed', 'prevented'].some(keyword => text.includes(keyword))) {
    severity = Math.max(1, severity - 1);
  }
  
  return severity;
}