import { NextRequest, NextResponse } from 'next/server';
import { createServerClient } from '@/lib/supabase/server';

interface CrimeIncident {
  severity: number;
  area?: string;
  alert_type: string;
  created_at: string;
}

export async function POST(request: NextRequest) {
  try {
    const { userId, timeRange } = await request.json();
    
    if (!userId) {
      return NextResponse.json({ error: 'User ID is required' }, { status: 400 });
    }

    const supabase = await createServerClient();
    
    // Calculate date range based on timeRange
    const now = new Date();
    const startDate = new Date();
    
    switch (timeRange) {
      case 'month':
        startDate.setMonth(now.getMonth() - 1);
        break;
      case 'quarter':
        startDate.setMonth(now.getMonth() - 3);
        break;
      case 'year':
        startDate.setFullYear(now.getFullYear() - 1);
        break;
      default:
        startDate.setMonth(now.getMonth() - 1);
    }

    // Fetch incidents for the user within the time range
    const { data: incidents, error: incidentsError } = await supabase
      .from('crime_incidents')
      .select('*')
      .gte('created_at', startDate.toISOString())
      .order('created_at', { ascending: false });

    if (incidentsError) {
      console.error('❌ Error fetching incidents:', incidentsError);
      return NextResponse.json({ error: 'Failed to fetch incidents' }, { status: 500 });
    }

    // Calculate analytics data
    const totalIncidents = incidents.length;
    const averageSeverity = incidents.length > 0 
      ? incidents.reduce((sum: number, incident: CrimeIncident) => sum + incident.severity, 0) / incidents.length 
      : 0;

    // Area statistics
    const areaStats = incidents.reduce((acc: Array<{ area: string; incident_count: number }>, incident: CrimeIncident) => {
      const area = incident.area ?? 'Unknown';
      const existing = acc.find((stat: { area: string; incident_count: number }) => stat.area === area);
      if (existing) {
        existing.incident_count++;
      } else {
        acc.push({ area, incident_count: 1 });
      }
      return acc;
    }, [] as Array<{ area: string; incident_count: number }>);

    // Severity distribution
    const severityDistribution = incidents.reduce((acc: Array<{ severity: number; count: number }>, incident: CrimeIncident) => {
      const existing = acc.find((stat: { severity: number; count: number }) => stat.severity === incident.severity);
      if (existing) {
        existing.count++;
      } else {
        acc.push({ severity: incident.severity, count: 1 });
      }
      return acc;
    }, [] as Array<{ severity: number; count: number }>);

    // Alert type breakdown
    const alertTypeBreakdown = incidents.reduce((acc, incident) => {
      const existing = acc.find((stat: { alert_type: string; count: number }) => stat.alert_type === incident.alert_type);
      if (existing) {
        existing.count++;
      } else {
        acc.push({ alert_type: incident.alert_type, count: 1 });
      }
      return acc;
    }, [] as Array<{ alert_type: string; count: number }>);

    // Sort by count (descending)
    areaStats.sort((a: { incident_count: number }, b: { incident_count: number }) => b.incident_count - a.incident_count);
    severityDistribution.sort((a: { severity: number }, b: { severity: number }) => a.severity - b.severity);
    alertTypeBreakdown.sort((a: { count: number }, b: { count: number }) => b.count - a.count);

    const analyticsData = {
      areaStats,
      severityDistribution,
      alertTypeBreakdown,
      recentIncidents: incidents.slice(0, 10), // Top 10 most recent
      totalIncidents,
      averageSeverity
    };

    console.log('✅ Analytics data generated:', analyticsData);

    return NextResponse.json(analyticsData);

  } catch (error) {
    console.error('❌ Analytics API error:', error);
    return NextResponse.json(
      { error: 'Failed to generate analytics' },
      { status: 500 }
    );
  }
}
